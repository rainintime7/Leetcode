# Leetcode
recording of solutions for leetcode

#### notice
- week01
剑指07
剑指09 复杂度
剑指10 矩阵快速幂
剑指13 dfs solution
剑指14 循环求余/快速幂求余
剑指16 (?)为什么n<0情况不处理会超时？
剑指17 做法
剑指26


20220316
剑指12 dfs
剑指13 bfs/dfs
两道搜索的题目，没看题解之前有点难，看了题解之后就是典型的搜索。12题需要注意的是有一个标记已经走过的格子，并且要还原的操作。13题的dfs解法还没看，因为第一感觉找所有连通格子适合bfs，晚上看。

20220317
剑指14-i dp
剑指14-ii dp + 大数情况/数学推理
dp思路关键在于状态转移方程的推导，但是在大数情况下会超时。数学推理可以直接推理出最优解（算是贪心？），另外涉及到一些取余运算。
剑指15 位运算
剑指16 快速幂
二进制理解快速幂，时间复杂度是log(N).要尤其注意n<0情况

20220321
剑指17 考虑大数情况，dfs递归实现全排列。疑问：大数情况是先用字符串表示然后将字符串转化成int，这个过程为什么可以避免大数越界？
剑指18 list。两个特殊情况：先考虑head会不会是null。其次考虑要删除的就是head结点情况。
剑指21 首位双指针/快慢双指针

20220322
jz 22 solution1-栈/solution2-双指针，可优化空间复杂度
jz 24 solution1-栈/solution2-递归/solution-3双指针
总结：链表反转类题三大思路-递归/栈/双指针。双指针一般是效率最优。

20220323
jz 25 1.递归/2.双指针遍历 技巧：保留最前面的指针
jz 26 树的递归，题解给出的代码很巧妙，在主函数里嵌套了递归。难点是递归边界条件，判断匹配成功和匹配失败的条件。注意点有递归步骤，递归终止条件，以及特殊情况（none）的处理。
jz 27 二叉树递归/栈，递归和栈可以互相转换

20220324
jz 28 二叉树递归
jz 29 设定边界？为什么这道题居然是简单题？

20220325
jz 30 有时间复杂度要求。正常是O(N)要求是O(1)所以一定会以空间代价换时间，引入额外的数据结构。本题中引入了一个额外的栈用于实现min。
jz 31 用一个辅助stack来模拟过程，模拟地出则为true，否则false
jz 32-i 二叉树层遍历 + 队列
jz 32-ii 上一题的变种，加入一个记号把每层分开
jz 32-iii 上一题变种，用双端队列 + 记录奇偶层
jz 33 二叉搜索树+递归+分治。利用二叉搜索树左子树<root<右子树的特点
jz 34 二叉树+递归+回溯。递归步骤难写。
总结：递归真的好难啊

20220329
jz 35 遍历时用哈希表记录，第二遍用哈希表构造/方法二思路：先复制后拆分
jz 36 递归+二叉搜索树性质。二叉搜索树中序遍历是递增序列。
jz 38 递归。字符串中的数字可重复，所以dfs+剪枝.用python也可以用set去重。

问题1.python中赋值次序
a, b = b, a
a, b, c = c, b, a
a, b, c = c, a+1, a+2

问题2.变量作用域
def fun1:
    a = []
    def fun2:
        a.append()
